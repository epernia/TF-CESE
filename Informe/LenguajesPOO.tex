\subsection{Lenguajes de POO para sistemas embebidos} \label{sec:lenguajesPOO}

En la actualidad existen muchos desarrollos de lenguajes de programación orientado a objetos de propósito general para sistemas embebidos. Puntualmente se han evaluado las siguientes alternativas:

\begin{itemize}
\item 
C++.
\item 
Java.
\item 
Python.
\end{itemize}


\titulo{Lenguaje C++}

El lenguaje de programación C++ se encuentra disponible para la mayoría de los sistemas embebidos del mercado. Básicamente, todo embebido  que dispone de un compilador de C, trae además, un compilador de C++. En este lenguaje se pueden manejar las interrupciones de un microcontrolador a través de funciones en C embebidas en el código C++. 

\medskip

No tiene soporte de manejo de \textit{threads} en el lenguaje, sino que debe programarse desde cero una aplicación que resuelva la concurrencia de procesos a bajo nivel.

\medskip

Es un lenguaje estáticamente tipado, es decir, cada variable debe ser declarada con un tipo, esto implica una ventaja para el programador ya que pueden detectarse en tiempo de compilación muchos errores por incompatibilidad de tipos de datos. 

\medskip

Si bien aplica los conceptos principales que debe tener un lenguaje orientado a objetos, el mismo es considerado obsoleto por ingenieros informáticos debido a que arrastra muchos conceptos de C que lo vuelven inseguro, como por ejemplo, permite manejar la memoria sin ninguna protección a través de punteros, una fuente habitual de errores. El manejo de memoria manual se extiende a la eliminación explicita de objetos, cuya responsabilidad recae sobre el programador. El tiempo de creación y destrucción de un objeto es variable, esto es una desventaja para aplicaciones de tiempo real. 
Tampoco incluye características modernas de lenguajes como, por ejemplo, bloques (\textit{closures}), o sintaxis simplificada para recorrer colecciones.

\medskip

Este lenguaje POO está disponible para utilizarse actualmente en las plataformas CIAA.


\bigskip
\titulo{Lenguaje Python}

Este lenguaje posee características modernas, entre ellas Garbage Collector, que es un proceso que se encarga de detectar que objetos en memoria no se utilizan y los borra automáticamente, liberando al programador de esta tarea. Sin embargo, al igual que el caso anterior es una desventaja para aplicaciones de timpo real pues su tiempo de ejecución no es determinista. 
No utiliza punteros, posee solamente referencias. A diferencia de C++, Python es un lenguaje interpretado en lugar de compilado.

\medskip

Es un lenguaje dinámicamente tipado, es decir una variable puede cambiar su tipo de datos según lo que contenga en cada momento, constituyendo una ventaja aparente para el programador al escribir el programa, pero los errores de incompatibilidad de datos solo se darán en tiempo de ejecución, dando más responsabilidad al programador para la detección de errores. Si bien en desarrollos unipersonales esto no es determinante, no se recomienda para grandes proyectos donde existan muchos programadores distribuidos. 

\medskip

El lenguaje Python posee soporte para el manejo de procesos, pero no se han encontrado especificaciones de soporte de procesos \textit{real-time}. 

\medskip

MicroPython es una implementación de un intérprete de lenguaje Python para sistemas embebidos. Durante el tiempo de realización de este trabajo, un grupo perteneciente al proyecto CIAA se portó este intérprete para poder ser utilizado sobre la plataforma EDU-CIAA-NXP. Sin embargo, el mismo no se recomienda para aplicaciones industriales.


\bigskip
\titulo{Lenguaje Java}

El lenguaje Java, uno de los lenguaje de programación más utilizados en la actualidad. Realiza un balance entre las mejores características de los dos anteriores y agrega otras faltantes. 

\medskip

Java tiene aspectos que lo hace más robusto y seguro, entre ellos, una especificación del lenguaje (JLS) que es independiente de cualquier implementación, que ayuda que existan diferentes implementaciones es muchas arquitecturas totalmente compatibles; todos los accesos al hardware son a través de la Máquina Virtual de Java (JVM), que no permite el accesos ilegales a zonas de memoria y ha sido diseñado para ser seguro para trabajar en red. 

\medskip

Para lograr la independencia de la máquina, Java posee la característica de ser un lenguaje compilado e interpretado. Todo programa en Java, se compila primero a un lenguaje similar a un \textit{assembler} genérico basando en pila (\textit{bytecodes}), que luego es interpretado por la JVM, dependiente de la plataforma.

\medskip

La JVM es habitualmente un programa que corre sobre un sistema operativo, sin embargo, existen implementaciones de la JVM que corren directamente sobre el hardware (\textit{bare-metal}) y procesadores capaces de ejecutar \textit{bytecodes} de Java directamente (por ejemplo, el microcontrolador ARM926EJ-S). Si bien es interpretado al igual que Python, existen disponibles muchas implementaciones de la JVM para distintas plataformas, no siendo este el caso de los intérpretes de Python.

\medskip

Posee comprobación estricta de tipos, como C++. Manejo de memoria automático mediante Garbage Collector y utiliza referencias al igual que Python. Además, permite programación concurrente de forma estándar y existen varias especificaciones de Java para aplicaciones de tiempo real. 

\medskip

En consecuencia, por todas las razones expuestas, se elige Java como lenguaje POO para el presente trabajo. Se introducen a continuación las especificaciones de Java RTSJ y SCJ.

%Fue desarrollado originalmente por James Gosling de Sun Microsystems y publicado en 1995 como un componente fundamental de la plataforma Java de Sun Microsystems (actualmente fue adquirida por la compañía Oracle). 

\subsection{Especificaciones RTSJ y SCJ} \label{sec:especificacionesJava}

En Java existen varias descripciones del lenguaje pensadas para la implementación \textit{threads real-time}, mitigando los puntos de desventaja del lenguaje Java para la programación de aplicaciones industriales. Una de ellas es la especificación RTSJ que contempla aplicaciones \textit{Real-Time}, otra es \textit{Predictable} Java (PJ), un subconjunto de RTSJ que agrega algunos conceptos. Esta última se ha utilizado como inspiración para SCJ, la cual agrega conceptos de sistemas críticos y seguridad funcional. Se describen a continuación las especificaciones RTSJ y SCJ.


\bigskip
\titulo{Especificación RTSJ}

La Especificación de Tiempo Real para Java (RTSJ), o JSR 1, indica cómo un sistema Java debería comportarse en un contexto de tiempo real. Fue desarrollada durante varios años por expertos de Java y de aplicaciones en tiempo real.

\medskip

Está diseñada para extender naturalmente cualquiera de las plataformas de la familia Java (Java, Java SE, Java EE, Java Micro Edition, etc.), y tiene el requerimiento de que cualquier implementación debe pasar el \textit{Test} de Compatibilidad JSR 1 (TCK) y el TCK propio de la plataforma en la cual está basada. 

\medskip

RTSJ introduce varias características nuevas para soportar operaciones en tiempo real. Estas características incluyen nuevos tipos de \textit{thread}, nuevos modelos de gestión de memoria, y nuevos \textit{frameworks}.

\medskip

Modela una aplicación de tiempo real como un conjunto de tareas, cada una de las cuales tiene una meta de tiempo opcional. Esta meta especifica cuando debe ser completada la tarea. Las tareas de tiempo real se pueden agrupar en varias categorías, basadas en cómo el desarrollador puede predecir su frecuencia y ejecución:

\begin{itemize}
\item
\textbf{Periódicas:} tareas que se ejecutan repetitivamente a una frecuencia fija.
\item
\textbf{Esporádicas:} tareas que no se ejecutan en una frecuencia fija, pero que tienen una frecuencia máxima.
\item
\textbf{Aperiódicas:} tareas cuya frecuencia y ejecución no pueden predecirse.
\end{itemize}

RTSJ utiliza información de los tipos de tarea para asegurar que las tareas críticas no incumplan sus metas. Permite asociarle a cada tarea un \textit{Handler} de Meta Incumplida, de manera que una tarea no se completa antes de su meta de tiempo, se invoca al \textit{handler} asociado para poder tomar medidas al respecto.

\medskip

Define la gestión de prioridades de los \textit{threads} con al menos 28 niveles de prioridad. Para evitar la inversión de prioridades utiliza herencia de prioridades para su gestión.

\medskip

Brinda diversas formas de reservar memoria para objetos. Los objetos pueden asignarse a un área de memoria específica. Estas áreas tienen diferentes características de \textit{gargabe collector} y límites de reserva. Se clasifican en:

\begin{itemize}
\item
\textbf{Heap estándar}. Como cualquier máquina virtual, RTJS mantiene un \textit{heap} con \textit{garbage collector} para que sea utilizado por cualquier tipo de tarea (\textit{real-time} o no).
\item
\textbf{Memoria inmortal}. Un área de memoria que no tiene un \textit{gargabe collector}, cuyo uso lo debe gestionar el programador.
\item
\textbf{Memoria de ámbito}. Sólo disponible para \textit{threads} de tiempo real (RTT\footnote{RTT son las siglas de \textit{Real-Time Thread}. Es la clase Java que implementa las tareas de tiempo real} y NHRT\footnote{NHRT significa \textit{No Heap Real-time Thread}. Es una subclase de RTT donde el \textit{garbage colletor} no actúa durante su ejecución. Destinada a tareas \textit{hard real-time}}). Estas áreas de memoria están pensadas para objetos con un tiempo de vida conocido. Al igual que la anterior no posee \textit{gargabe collector}.
\end{itemize}


\bigskip
\titulo{Especificación SCJ}

La especificación \textit{Safety-Critical} Java, (JSR-302), es un subconjunto de la especificación RTSJ, que además, define un conjunto de servicios diseñados para ser utilizados en aplicaciones que requieran un nivel de certificación de seguridad funcional.
La especificación está dirigida a una amplia variedad de paradigmas de certificación muy exigentes, tales como los requisitos de seguridad crítica DO-178B, Nivel A.

\medskip

Esta especificación presenta un conjunto de clases Java que implementan soluciones \textit{Safety-Critical} para el inicio de la aplicación, concurrencia, planificación, sincronización, entrada/salida, gestión de memoria, gestión de temporización, procesamiento de interrupciones, interfaces nativas y excepciones.
Presenta un conjunto de \textit{annotations} que pueden ser utilizadas para garantizar que la aplicación exhibe ciertas propiedades de seguridad funcional, mediante comprobación estática, para mejorar la certificación de aplicaciones construidas para ajustarse a esta especificación.

\medskip

Para aumentar la portabilidad de las aplicaciones \textit{Safety-Critical} entre distintas implementaciones de esta especificación, se enumera un conjunto mínimo de bibliotecas Java que deben ser proporcionados en una implementación conforme a la especificación.

\bigskip
\titulo{Modelo de programación SCJ}

En esta especificación solo se permiten \textbf{\textit{Threads Real-Time}} a diferencia de RTSJ. 
Un programa SCJ se organiza en \textbf{Misiones}\footnote{\textit{Missions} en su idioma original}. 
Una misión encapsula una funcionalidad específica, o una fase, en el tiempo de vida de del sistema en tiempo real como un conjunto de \textbf{entidades planificables}\footnote{\textit{schedulable entities} en su idioma original.}. 
Por ejemplo, un sistema de control de vuelo puede estar compuesto de despegue, crucero y aterrizaje; pudiendo dedicarse a cada una una misión.
Una entidad planificable maneja una funcionalidad específica y tiene parámetros de liberación que describen el modelo de liberación y alcance temporal, por tiemplo tiempo de liberación y \textit{dedline}. 
El patrón de liberación es periódico o aperiódico.

\medskip

El concepto de misión se representa en la figura [\ref{fig:missionsSCJ}] y contiene cinco fases:

\begin{itemize}
\item 
\textbf{Configuración:} donde se asignan en memoria los objetos de la misión. Esto se hace durante el arranque del sistema y no se considera de tiempo critico.
\item 
\textbf{Inicialización:} donde se realizan todas las asignaciones de objetos relacionados con la misión o de la totalidad de la aplicación. Esta fase no es de tiempo crítico.
\item 
\textbf{Ejecución:} durante el cual se ejecuta toda la lógica de aplicación y entidades planificables se preparan para su ejecución de acuerdo con un planificador apropiativo. Esta fase es de tiempo crítico.
\item 
\textbf{Limpieza:} se ingresa cuando termina la misión y se utiliza para completar la ejecución de todas las entidades planificables, así como la realización de funciones relacionadas con limpieza de memoria. Después de esta fase, la misma misión puede ser reiniciada, se selecciona una nueva, o bien, se ingresa en la fase de desmontaje. Esta fase no es de tiempo crítico.
\item 
\textbf{Desmontaje:} es la fase final de la vida útil de la aplicación y se compone de la liberación de memoria de los objetos y otros recursos. Esta fase no es de tiempo crítico.
\end{itemize}

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=16cm,height=5cm]{figuras/MisionSCJ.png}
\par\caption{Concepto de misión SCJ.}\label{fig:missionsSCJ}
\end{center}
\end{figure}

Se utiliza un \textbf{secuenciador de misión} para regular el orden de los objetos de misión que puede ser personalizado para la aplicación.

\medskip

SCJ presenta un modelo de memoria basado en el concepto de \textbf{ámbitos de memoria} de RTSJ, evitando el uso del \textit{heap} con \textit{garbage collector} para facilitar la verificación de los sistemas de SCJ. El modelo de memoria SCJ se muestra en la Figura [\ref{fig:memoriaSCJ}] e introduce tres niveles de memorias, estos son:

\begin{itemize}
\item 
\textbf{\textit{Memoria Privada.}} Se asocia a cada \textit{handler} de eventos \textit{real-time}. Esta memoria privada existe durante toda la duración del \textit{handler} y se borra al finalizar.
\item 
\textbf{\textit{Memoria Inmortal.}} Es el área deque perdura durante toda la vida útil del sistema quedando a cargo del programador.
\item 
\textbf{\textit{Memoria de Misión.}} Se asocia con cada misión del sistema y como tal gestiona la memoria de todos los \textit{handlers} de tiempo real de la misión, así como los objetos compartidos entre \textit{handlers}. Cuando una misión completa su ejecución se borra su memoria asociada.
\end{itemize}

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=14cm,height=6.5cm]{figuras/MemoriaSCJ.png}
\par\caption{Modelo de memoria SCJ.}\label{fig:memoriaSCJ}
\end{center}
\end{figure}

\bigskip
\titulo{Niveles conformidad con la especificación SCJ}

Existen 3 niveles conformidad con la especificación SCJ, dependiendo de las prestaciones ofrecidas:

\begin{itemize}
\item 
\textbf{Nivel 0}. Proporciona una ejecución cíclica (un único \textit{thread}), sin \textit{wait/notify}.
\item 
\textbf{Nivel 1}. Provee una única \textbf{Misión} con múltiples \textbf{Objetos planificables}.
\item 
\textbf{Nivel 2}. Ofrece \textbf{Misiones} anidadas (limitadas) con \textbf{ámbitos de memoria} anidados (limitados).
\end{itemize}


