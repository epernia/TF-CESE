\section{Diseño de biblioteca para el manejo de periféricos desde Java} \label{sec:disenoAPI}

Proveer el manejo de periféricos de la CIAA directamente desde Java es requisito fundamental para que tenga sentido la adopción de este lenguaje. 

\medskip

En Java, esto se traduce a la necesidad de diseñar una biblioteca Java para el manejo de periféricos.
Una biblioteca de Java se compone de un conjunto de Clases Java empaquetadas en un archivo de extensión \textbf{.jar}. 
El alcance de esta biblioteca para el presente trabajo es permitir la utilización de los siguientes periféricos:

\begin{itemize}
\item
Entradas y salidas digitales.
\item
Entradas y salidas analógicas.
\item
Periférico de comunicación serie (UART).
\end{itemize}

Para la construcción de esta biblioteca se utilizarán métodos nativos escritos en lenguaje C.
En consecuencia, se necesita obtener una implementación de bibliotecas de C para estos periféricos y luego programar los métodos nativos que formarán parte de las Clases Java que componen la biblioteca.

\medskip

Al comienzo se analizó la estructura del Firmware de la CIAA (que está realizado en lenguaje C) para intentar compatibilizar HVM con el mismo, con el interés de reutilizar el manejo de periféricos mediante \textbf{Posix} y el protocolo \textbf{Modbus} para HVM. En la figura [\ref{fig:EstructuraCiaaFirmware}] se ilustra la estructura en capas (simplificada) del Firmware de la CIAA. 

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=9cm,height=8cm]{figuras/EstructuraCiaaFirmware.png}
\par\caption{Estructura en capas del Firmware de la CIAA.}\label{fig:EstructuraCiaaFirmware}
\end{center}
\end{figure}

\medskip
Se descubrió que los módulos de interés dependen de \textbf{FreeOSEK}, el sistema operativo de tiempo real, que provee manejo de tareas mediante un planificador apropiativo, alarmas, eventos, recursos y \textit{handlers} de interrupción. 
HVM realiza las mismas tareas que OSEK y está diseñada para correr directamente sobre el hardware, entonces, no es posible lograr fácilmente una convivencia entre ambos en una misma aplicación. Para realizarlo, una  estrategia sería reformar HVM para que corra sobre OSEK.
Otra posibilidad es reescribir las partes de los módulos Posix y Modbus que dependen de FreeOSEK para que utilicen servicios de HVM. Ambas tareas demandan bastante trabajo.

\medskip

Por otro lado Posix utiliza una filosofía donde todos los periféricos se acceden como un \textit{stream} de bytes (concepto de todo es un archivo) mediante las funciones \textit{open, close, read, write} e \textit{ioctl}. Si bien es una abstracción muy eficiente, resulta poco natural para programadores ajenos a los sistemas Unix. 

\medskip

En los siguientes apartados se presentan las distintas características del diseño propuesto para esta biblioteca.


\subsection{Modelo de la biblioteca Java} \label{sec:disenoModeloBib}

Para el modelado de la biblioteca de Java se persiguen los siguientes objetivos:

\begin{itemize}
\item
Abstraer y simplificar la configuración del Hardware.
\item
De uso fácil para programadores informáticos y gente familiarizada con otras plataformas de hardware.
\item
Independiente del sistema operativo (en este caso HVM).
\end{itemize}

Se enfoca la misma a los conceptos que manejan los programadores en entornos industriales. Allí el dispositivo de uso más masivo es el PLC\footnote{Siglas de Controlador Lógico Programable.} donde los conceptos que se manejan son los de dispositivos de entrada, salida y comunicaciones.

\medskip

Se propone modelar el concepto de \textbf{Dispositivo} que se compone de \textbf{Periféricos}. Los periféricos se clasifican en:

\begin{itemize}
\item
\textbf{DigitalIO}. Modela una entrada o salida cuyo valor lo representa un booleano.
\item
\textbf{AnalogIO}. Modela una entrada o salida cuyo valor lo representa un número entero.
\item
\textbf{Uart}. Modela el periférico de comunicación serie, UART.
\end{itemize}

Como en las plataformas de hardware existe más de un periférico de cada tipo, se debe poder identificar a cada uno en particular. 

\medskip

Cada periférico utiliza uno o más de pines del microcontrolador. 
En la plataforma CIAA-NXP esta relación es fija por diseño y no tiene sentido configurar cada pin para otra funcionalidad que no sea la asociada a su hardware de salida. 
En la EDU-CIAA-NXP, en cambio, esto es distinto porque se dispone de los pines directos que salen del microcontrolador pudiéndose utilizar para cualquier propósito. 
Un pin puede ser compartido por varios periféricos. Es por esto que se agrega al modelo el concepto de \textbf{Pin} de un periférico, que sirve para mantener la relación física del periférico con el microcontrolador. 
El Pin también sirve para determinar si un pin está en uso por un periférico cuando se intente usar dos periféricos distintos que utilicen los mismos pines físicos.

\medskip

Los métodos públicos para el acceso a un periférico son:

\begin{itemize}
\item
\textbf{read()}. Método para leer el periférico.
\item
\textbf{write()}. Método para escribir el periférico.
\item
\textbf{config()}. Método para configurar el periférico.
\end{itemize}

En la figura [\ref{fig:ModeloPeriferico}] se ofrece el modelo de Periférico (se han simplificado en el mismo tipos de datos). 

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=12cm,height=8cm]{figuras/ModeloPeriferico.png}
\par\caption{Modelo de Periférico.}\label{fig:ModeloPeriferico}
\end{center}
\end{figure}

Una clase \textbf{\textit{Peripheral}} define los métodos propuestos para el acceso, que luego son redefinidos en cada una de las subclases las cuales contienen la implementación concreta de cada tipo de periférico. Esta implementación incluye los métodos nativos que se deben implementar en C. En el métod constructor del objeto Periférico se deben establecer un identificador de dispositivo constante (id) y los pines físicos que usará el dispositivo (también definidos como constantes).

\medskip

Existe una jerarquía de clases similar para \textbf{\textit{PeripheralConfig}}, que se utilizan como parámetros para la configuración de los periféricos.

\medskip

El diagrama de como se articula un periférico con las otra clases se muestra en la figura [\ref{fig:ModeloDevice}].
Un \textbf{\textit{Device}} contiene una colección de pines y una de periféricos. Contiene métodos para añadir tanto periféricos como pines, y consultar si está en uso un pin. Contiene métodos estáticos para la construcción de instancias para cada plataforma (EDU-CIAA-NXP y CIAA-NXP) con todos sus periféricos y pines construidos.

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=16cm,height=6cm]{figuras/ModeloDevice.png}
\par\caption{Modelo de Dispositivo y Pin.}\label{fig:ModeloDevice}
\end{center}
\end{figure}


\medskip

El \textbf{\textit{Pin}} contiene varios atributos constantes, que se asignan en el método constructor, uno corresponde a un id único de pin y los otros son indicaciones de que tipo de periféricos soporta. También tiene un atributo que referencia al periférico que tenga tomado al pin.


\subsection{Mapeo de pines de las plataformas} \label{sec:disenoMapeo}

Con el diseño propuesto se debe mapear los pines de las plataformas. En este se deciden los números de pines, sus identificadores y se asignan las posibles funciones. En la figura [\ref{fig:MapeoCiaa}] se muestra el mapeo de pines de la CIAA-NXP, mientras que en la figura  [\ref{fig:MapeoEduCiaa}] se ilustra el de la EDU-CIAA-NXP.

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=17.5cm,height=12.5cm]{figuras/MapeoCiaa.png}
\par\caption{Mapeo de pines de la plataforma CIAA-NXP.}\label{fig:MapeoCiaa}
\end{center}
\end{figure}

Debido a que los pines de la EDU-CIAA-NXP tienen muchas funcionalidades posibles se resumieron como DI (\textit{Digital Input}), DO (\textit{Digital Output}), AI (\textit{Analog Input}), AO (\textit{Analog Output}) y U (Uart).

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=17.5cm,height=9cm]{figuras/MapeoEduCiaa.png}
\par\caption{Mapeo de pines de la plataforma EDU-CIAA-NXP.}\label{fig:MapeoEduCiaa}
\end{center}
\end{figure}

\newpage
\subsection{Modelo de la biblioteca en C} \label{sec:disenoModeloBibC}

Debido a que readaptar el Firmware de la CIAA era una tarea muy ardua se optó por crear una biblioteca en C que de el soporte necesario para los métodos nativos.

\medskip

Cada periférico se modela con una estructura de configuración, y las siguientes funciones asociadas:

\medskip

\noindent \textit{DigitalIO:}
\begin{lstlisting}
bool_t digitalConfig( int32_t pinID, int32_t mode )
bool_t digitalRead( int32_t pinID )
bool_t digitalWrite( int32_t pinID, bool_t value )
\end{lstlisting} 
\textit{AnalogIO:}
\begin{lstlisting}	
bool_t analogConfig( int32_t pinID, int32_t mode )
int32_t analogRead( int32_t pinID )
bool_t analogWrite( int32_t pinID, int32_t value )
\end{lstlisting}
\textit{UART:}
\begin{lstlisting}
bool_t uartConfig( int32_t uartID, int32_t baudRate )
bool_t uartAdvancedConfig( int32_t uartID, uartConfig_t * uartConfig )
uint8_t uartRead( int32_t uartID )
bool_t uartWrite( int32_t uartID, uint8_t byte )
\end{lstlisting}

Se diseña la misma para permitir también su uso \textit{bare-metal}.
