\section{Diseño de biblioteca para el manejo de periféricos desde Java} \label{sec:disenoAPI}

Proveer el manejo de periféricos de la CIAA directamente desde Java es requisito fundamental para que tenga sentido la adopción de este lenguaje. 

\medskip

En Java, esto se traduce a la necesidad de diseñar una biblioteca Java para el manejo de periféricos.
Una biblioteca de Java se compone de un conjunto de Clases Java empaquetadas en un archivo de extensión \textbf{.jar}. 
El alcance de esta biblioteca para el presente trabajo es permitir la utilización de los siguientes periféricos:

\begin{itemize}
\item
Entradas y salidas digitales.
\item
Entradas y salidas analógicas.
\item
Periférico de comunicación serie (UART).
\end{itemize}

Para la construcción de esta biblioteca se utilizarán métodos nativos escritos en lenguaje C.
En consecuencia, se necesita obtener una implementación de bibliotecas de C para estos periféricos y luego programar los métodos nativos que formarán parte de las Clases Java que componen la biblioteca.

\medskip

Al comienzo se analizó la estructura del Firmware de la CIAA (que està escrito en lenguaje C) para intentar compatibilizar HVM con el mismo, con el interés de reutilizar el manejo de periféricos mediante \textbf{Posix} y el protocolo \textbf{Modbus} para HVM. En la figura [\ref{fig:EstructuraCiaaFirmware}] se ilustra la estructura en capas (simplificada) del Firmware de la CIAA. 

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=9cm,height=8cm]{figuras/EstructuraCiaaFirmware.png}
\par\caption{Estructura en caps del Firmware de la CIAA.}\label{fig:EstructuraCiaaFirmware}
\end{center}
\end{figure}

\medskip
Se descubrió que los módulos de interés dependen de \textbf{FreeOSEK}, el sistema operativo de tiempo real, que provee manejo de tareas mediante un planificador apropiativo, alarmas, eventos, recursos y \textit{handlers} de interrupción. 
HVM realiza las mismas tareas que OSEK y está diseñada para correr directamente sobre el hardware, entonces, no es posible lograr fácilmente una convivencia entre ambos en una misma aplicación. Para realizarlo, una  estrategia sería reformar HVM para que corra sobre OSEK.
Otra posibilidad es reescribir las partes de los módulos Posix y Modbus que dependen de FreeOSEK para que utilicen servicios de HVM. Ambas tareas demandan bastante trabajo.

\medskip

Por otro lado Posix utiliza una filosofía donde todos los periféricos se acceden como un \textit{stream} de bytes (concepto de todo es un archivo) mediante las funciones \textit{open, close, read, write} e \textit{ioctl}. Si bien es una abstracción muy eficiente, resulta poco natural para programadores ajenos a los sistemas Unix. 

\medskip

En los siguientes apartados se presentan las distintas características del diseño propuesto para esta biblioteca.


\subsection{Modelo de la biblioteca} \label{sec:disenoModeloBib}

Para el modelado de la biblioteca de Java se persiguen los siguientes objetivos:

\begin{itemize}
\item
Abstraer y simplificar la configuración del Hardware.
\item
De uso fácil para programadores informáticos y gente familiarizada con otras plataformas de hardware.
\item
Independiente del sistema operativo (en este caso HVM).
\end{itemize}

Se enfoca la misma a los conceptos que manejan los programadores en entornos industriales. Allí el dispositivo de uso más masivo es el PLC\footnote{Siglas de Controlador Lógico Programable.} donde los conceptos que se manejan son los de dispositivos de entrada, salida y comunicaciones.

\medskip

Se propone modelar el concepto de \textbf{Dispositivo} que se compone de \textbf{Periféricos}. Los periféricos se clasifican en:

\begin{itemize}
\item
\textbf{DigitalIO}. Modela una entrada o salida cuyo valor lo representa un booleano.
\item
\textbf{AnalogIO}. Modela una entrada o salida cuyo valor lo representa un número entero.
\item
\textbf{Uart}. Modela el periférico de comunicación serie, UART.
\end{itemize}

Como en las plataformas de hardware existe más de un periférico de cada tipo, se debe poder identificar a cada uno en particular. 

\medskip

Cada periférico utiliza uno o más de pines del microcontrolador. 
En la plataforma CIAA-NXP esta relación es fija por diseño y no tiene sentido configurar cada pin para otra funcionalidad que no sea la asociada a su hardware de salida. 
En la EDU-CIAA-NXP, en cambio, esto es distinto porque se dispone de los pines directos que salen del microcontrolador pudiéndose utilizar para cualquier propósito. Aquí un pin puede ser compartido por varios periféricos. Se agrega al modelo, entonces, el concepto de \textbf{Pin} de un periférico que sirve para mantener la relación física del periférico con el microcontrolador. El Pin también sirve para determinar si un pin está en uso por un periférico cuando se intente usar dos periféricos distintos que utilicen los mismos pines físicos.

\medskip

Los métodos públicos para el acceso a un periférico son:

\begin{itemize}
\item
\textbf{read()}. Método para leer el periférico.
\item
\textbf{write()}. Método para escribir el periférico.
\item
\textbf{config()}. Método para configurar el periférico.
\end{itemize}

En la figura [\ref{fig:ModeloPeriferico}] se ofrece el modelo de Periférico (se han simplificado en el mismo tipos de datos). 

\begin{figure}[!htbp]
\begin{center}
\includegraphics*[width=12cm,height=8cm]{figuras/ModeloPeriferico.png}
\par\caption{Modelo de Periférico.}\label{fig:ModeloPeriferico}
\end{center}
\end{figure}

Una clase \textbf{\textit{Peripheral}} define los métodos propuestos para el acceso, que luego son redefinidos en cada una de las subclases que contienen la implementación concreta de cada tipo de periférico.

\medskip




%Pin digital Input/Output
%	digitalRead()
%	digitalWrite()
%	pinMode()
%
%Port digital Input/Output
%	portMode()
%	portRead()
%	portWrite()
%
%Pin analog Input
%	analogRead()
%	analogReference()
%
%Pin PWM (analog) Output
%	analogWrite()
%	noAnalogWrite()






\medskip


 para permitir también su uso \textit{bare-metal}.
