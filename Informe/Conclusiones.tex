\chapter{CONCLUSIONES Y TRABAJO A FUTURO}

\section{Conclusiones}

% Que se logoro realizar (de objetivos) --> implementacion.
% Que se logoro realizar (no planeado inicialmente) --> implementacion.
% Que se diseño --> Diseño.
	% Metodología aplicada 
		% --> Diseño iterativo con implementaciones de referencia.
	% Desafios a lo largo del proyecto.
% Que conocimientos puse en práctica de la Especializacion.
% Conocimientos adquiridos.
% Reflexion final.

En el presente Trabajo Final se ha logrado obtener un entorno de desarrollo para aplicaciones Java SCJ sobre las plataformas CIAA-NXP y EDU-CIAA-NXP, que además de ser software libre, cubre las necesidades planteadas, tanto al ofrecer programación orientada a objetos, así como funcionalidades de tiempo real para entornos industriales, sobre sistemas embebidos.

\medskip

Como subproducto, se obtiene además una biblioteca con una API sencilla para el manejo de periféricos de las plataformas CIAA-NXP y EDU-CIAA-NXP, que puede utilizarse en aplicaciones Java, o directamente en lenguaje C, debido a su diseño como módulo de Firmware de la CIAA. Se ha tenido especial cuidado en el diseño de esta biblioteca para que la misma sea lo más genérica posible logrando que además se comporte como una HAL.

% Metodología aplicada 
	% --> Diseño iterativo con implementaciones de referencia.

% Desafios a lo largo del proyecto.

\medskip

El desarrollo de este Trabajo Final demandó la articulación de conocimientos  adquiridos a lo largo de la Carrera de Especialización en Sistemas Embebidos, en especial las asignaturas:

\begin{itemize}
\item
\textbf{Arquitectura de microprocesadores}. Se utilizaron de esta asignatura los conocimientos adquiridos sobre la arquitectura ARM Cortex M necesarios para implementar en lenguaje \textit{assembler} las funciones que realizan el cambio de contexto, necesarias para que funcione el concepto de Proceso SCJ. 
\item
\textbf{Programación de microprocesadores}. De esta asignatura se aprovecha la experiencia sobre lenguaje C para microcontroladores de 32 bits y el manejo de sus periféricos. Fue de especial importancia, debido a que, a excepción de unas pocas, todas las funciones para portar HVM a la CIAA debían realizarse en lenguaje C. Este lenguaje también se utilizó en la creación de  la API para el manejo de periféricos.
\item
\textbf{Ingeniería de software en sistemas embebidos}. Se aplican de la misma las metodologías de trabajo, provenientes de la ingeniería de software, que aportan calidad y eficiencia la desarrollo. En particular, diseño iterativo, manejo repositorios de software y diseño modular en capas.
\item
\textbf{Gestión de Proyectos en Ingeniería}. Durante esta se desarrolló el Plan de Proyecto del Trabajo Final, permitiendo desde un principio tener una clara planificación del trabajo a realizar. 
\item
\textbf{Sistemas Operativos de Proposito General}. Se aprovechan los conocimientos adquiridos sobre Linux para probar las herramientas desarrolladas sobre este sistema operativo.
\item
\textbf{Sistemas Operativos de Tiempo Real (I y II)}. De estas asignaturas se aplica el conocimiento obtenido sobre planificadores de tareas expropiativos y la manera en que trabajan. Esto ha sido muy importante para la realización de este Trabajo Final. También la creación de módulos de Firmware para la CIAA.
\item
\textbf{Desarrollo de Sistemas Embebidos en Android}. La plataforma Andoid es un claro caso de éxito de la aplicación de un lenguaje POO en sistemas embebidos (aunque no sea para aplicaciones induistriales). Estas aplicaciones se realizan en lenguaje Java. Si bien se contaba con experiencia en programación orientada a objetos en otros lenguajes, esta asignatura fue para el autor el primer acercamiento a dicho lenguaje. En consecuencia, mucho de lo aprendido colaboró en la decisión de llevar a cabo este trabajo.
\item
\textbf{Diseño de Sistemas Críticos}. Los conceptos aprendidos en esta asignatura contribuyeron a comprender, inmediatamente, las importantes implicancias de poder programar aplicaciones SCJ en sistemas embebidos para aplicaciones industriales.
\end{itemize}

\medskip

\noindent Además, se han adquirido aprendizajes en las temáticas:

\begin{itemize}
\item
Programación de aplicaciones en lenguaje Java.
\item
Especificaciones de Java, entre ellas, RTSJ y SCJ.
\item
Programación de aplicaciones SCJ.
\item
Experiencia en implementación de cambio de contexto, procesos y planificadores.
\item
Máquinas Virtuales de Java para sistemas embebidos y su funcionamiento interno.
\item
Desarrollo de una biblioteca Java para manejo de periféricos en sistemas embebidos. Conexión con bibliotecas nativas en lenguaje C.
\end{itemize}

\medskip

Por lo tanto, se llega a la conclusión que los objetivos planteados al comenzar el trabajo han sido alcanzados satisfactoriamente, y además, se han adquirido conocimientos muy importantes para la formación profesional del autor.


%\section{Conclusión}
%
%
%En este trabajo se ha logrado llevar a cabo un diseño completo de un micro PLC, incluyendo especificaciones de Hardware, Software base (sistema operativo, drivers, implementaciones de funciones standard, etc.), y formato que debe respetar el resultado de la compilación de programas definidos en los lenguajes de la norma IEC61131-3, para poder ejecutarse en equipos que se correspondan con el modelo diseñado.
%
%\medskip
%
%Por otra parte, se definen en detalle los siguientes aspectos salientes para la implementación de un entorno de edición de programas para PLC: comportamiento esperado de la interfaz de usuario, y requisitos que debe cumplir un modelo computacional de los conceptos y lenguajes de programación descriptos en la norma citada.
%
%\medskip
%
%Se buscó generar especificaciones que no dependieran de determinados componentes o fabricantes para el Hardware, ni de un Sistema Operativo específico para el entorno de edición de programas. Permitiendo así, construir un PLC de bajo costo de Hardware, de forma tal que pueda ser utilizado en ámbitos académicos y que, al mismo tiempo, permitan la edición de programas en forma ágil y cómoda, en particular para los lenguajes gráficos (Ladder y FBD) incluidos en la norma.
%
%\medskip
%
%Como parte del trabajo, se desarrolló una implementación que cumple con las pautas y definiciones incluidas en las distintas partes del diseño, utilizando componentes de Hardware económicos y fácilmente obtenibles; y un entorno de programación (para desarrollar el entorno de edición de programas) que puede obtenerse desde Internet en forma gratuita.
%
%\medskip
%
%Por lo tanto, se llega a la conclusión que los objetivos planteados al comenzar el trabajo han sido alcanzados satisfactoriamente.
%
%\medskip
%
%La definición del diseño fue llevada a cabo en conjunto, y en muchos casos influida por la construcción de implementaciones de referencia. Se culmina este Trabajo Final con la férrea convicción que esta manera de realizarlo, permitió llegar a diseños más acabados, brindando pautas concretas y realmente útiles para el desarrollo de futuras implementaciones.
%
%\medskip
%
%Por otro lado, el trabajo resultó sumamente arduo en varios aspectos; entre los se destacan: 
%
%\begin{itemize}
%\item 
%La gran cantidad de iteraciones y versiones preliminares que culminaron en la especificación presentada del modelo computacional referente a los conceptos y lenguajes de programación incluidos en la norma IEC61131-3.
%\item 
%La complejidad inherente a algunos detalles de la implementación de la interfaz de usuario para lenguajes gráficos, en particular el recálculo de las posiciones ante distintas acciones que puede llevar a cabo el usuario en un segmento de programa en lenguaje Ladder. 
%\end{itemize}
%
%Considerando este último aspecto, si bien algunas características del Framework Morphic ayudaron en la implementación de referencia de la GUI, la poca documentación existente sobre esta herramienta, hizo que en muchas oportunidades fuera necesario revisar el código de sus clases constituyentes, recurriendo a las capacidades avanzadas de depuración de Pharo, que permiten examinar y modificar el código de su propia interfaz en tiempo de ejecución.
%
%\medskip
%
%Cabe resaltar que la utilización de los conceptos principales del paradigma de programación orientada a objetos, facilitó el desarrollo del diseño y su implementación de referencia. 
%En particular, contribuyó a manejar la gran complejidad del modelo computacional de una Configuración de Software y de los programas incluidos, permitiendo la obtención de componentes bien definidos e interfaces claras entre los mismos, logrando que componentes de distintas características (como por ejemplo, los segmentos que corresponden a distintos lenguajes de programación IEC61131-3) puedan ensamblarse en forma sencilla dentro de un mismo diseño general.
%
%\medskip
%
%Además, el desarrollo de un modelo computacional adecuado referente a los conceptos de distintos lenguajes de programación, involucró investigar y adquirir conocimientos avanzados de programación, por ejemplo; tipos de datos, definiciones, declaraciones, parseo, compilación, etc. 
%
%
%\medskip
%
%Otra herramienta clave para llevar a cabo esta labor, fue la experiencia adquirida en programación de Microcontroladores, siendo, el autor de este trabajo, alumno y auxiliar académico en las materias correspondientes, hecho que contribuyó en la investigación de uno de los Microcontroladores (y su IDE de desarrollo) más novedosos disponible en el mercado, utilizado para la implementación de referencia del Hardware.
%
%\medskip
%
%Concluyendo, la realización de este Trabajo Final demandó la articulación entre los conocimientos adquiridos a lo largo de la carrera y los aprendizajes incorporados, habilitando su puesta en práctica.


\section{Trabajo a futuro}

\noindent Como labor a futuro, pueden realizarse las siguientes tareas:

\begin{itemize}
\item
Programar los \textit{Launchers} para las plataformas CIAA y EDU-CIAA-NXP para permitir \textit{debuggear} directamente en Java.
\item
Completar una versión del IDE lista para instalar y utilizar fácilmente. 
\item
Publicar el desarrollo en un repositorio público y crear tutoriales de uso.
\item
Integrar el \textit{port} de la CIAA al repositorio oficial de HVM.
\item
Investigar HVM-TP, el nuevo desarrollo de Stephan Erbs Korsholm. Es una máquina virtual de Java \textit{Time Predictable} y Portable para sistemas embebidos \textit{Hard Real-Time}, que toma como base a HVM, extendiéndola y mejorando sus capacidades.

% HVMTP: A Time Predictable and Portable Java Virtual Machine for Hard Real-Time Embedded Systems - JTRES 2014 - Kasper Søe Luckow1 Bent Thomsen1 Stephan Erbs Korsholm2

\end{itemize} 
